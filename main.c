/******************************************************************************
*
* Copyright (c) 2015-2021, Infineon Technologies AG
* All rights reserved.
*
* Boost Software License - Version 1.0 - August 17th, 2003
*
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (the "Software") to use, reproduce, display, distribute,
* execute, and transmit the Software, and to prepare derivative works of the
* Software, and to permit third-parties to whom the Software is furnished to
* do so, all subject to the following:
*
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*
*****************************************************************************/

#include "IMR_CAN_GLOBAL.h"
#include "cybsp.h"
#include "cy_utils.h"

#include "IMR_CAN.h"
#include "LED_Control.h"
#include <stdint.h>

#define DEBUG_MODE			(0U)			// Debug Mode to initially start LEDs (Used for testing Boards & LEDs); 		0U ... Debug Mode OFF; 		1U ... Debug Mode ON;
uint32_t board_id = 0;
uint32_t chaser_start = 0;

/****************************************************************************/

void TIMER_LED_PERIOD_MATCH_EVENT_HANDLER(void) {
	switch(current_mode) {
		case LED_MODE_OFF:
		{
			OffLight();
			XMC_CCU4_SLICE_StopTimer(TIMER_LED_HW);		// Stop the CCU4 timer
			break;
		}
		case LED_MODE_CHASER:
		{
			if (TimeStampLED >= chaser_start && TimeStampLED < chaser_start + LED_Count + 4) {
				//do chaser step
				uint32_t cur = TimeStampLED - chaser_start;

				if (cur < LED_Count) {
					LEDOn(cur, 4);
				}

				if (cur >= 1) LEDOn(cur-1, 1);
				if (cur >= 3) LEDOn(cur-3, 4);
				if (cur >= 4) {
					LEDOff(cur-4);
				}
			}

			if (TimeStampLED == 23) {
				if (board_id == 0) {
					CAN_TX_Request(LED_LAYER_1_LEFT, CAN_DATA, 8);
					CAN_TX_Request(LED_LAYER_2_LEFT, CAN_DATA, 8);
					CAN_TX_Request(LED_LAYER_3_LEFT, CAN_DATA, 8);
				}
				if (board_id == 4) {
					CAN_TX_Request(LED_LAYER_1_RIGHT, CAN_DATA, 8);
					CAN_TX_Request(LED_LAYER_2_RIGHT, CAN_DATA, 8);
					CAN_TX_Request(LED_LAYER_3_RIGHT, CAN_DATA, 8);
				}
			}
			if (TimeStampLED == 5) {
				if (board_id == 3) {
					CAN_TX_Request(LED_LAYER_1_BACK, CAN_DATA, 8);
					CAN_TX_Request(LED_LAYER_2_BACK, CAN_DATA, 8);
					CAN_TX_Request(LED_LAYER_3_BACK, CAN_DATA, 8);
				}
				if (board_id == 7) {
					CAN_TX_Request(LED_LAYER_1_FRONT, CAN_DATA, 8);
					CAN_TX_Request(LED_LAYER_2_FRONT, CAN_DATA, 8);
					CAN_TX_Request(LED_LAYER_3_FRONT, CAN_DATA, 8);
				}
			}

			TimeStampLED++;
			break;
		}
		case LED_MODE_PULSE:
		{
			if(PulsingLight(TimeStampLED++, PULSING_TIME_TO_BRIGHTEST)) {
				TimeStampLED = 0;
			}
			break;
		}
		case LED_MODE_STEADY:
		{
			SteadyLight();
			break;
		}
	}

	SendRGB(&strip);		// Update LED Values
}

/****************************************************************************/

 int main(void) {
	cybsp_init();		/* Initialize the device and board peripherals */

	board_id = 0;
		board_id |= (uint8_t) (!XMC_GPIO_GetInput(CAN_ID1_PORT, CAN_ID1_PIN) << 0);
		board_id |= (uint8_t) (!XMC_GPIO_GetInput(CAN_ID2_PORT, CAN_ID2_PIN) << 1);
		board_id |= (uint8_t) (!XMC_GPIO_GetInput(CAN_ID3_PORT, CAN_ID3_PIN) << 2);
		board_id |= (uint8_t) (!XMC_GPIO_GetInput(CAN_ID4_PORT, CAN_ID4_PIN) << 3);
		board_id |= (uint8_t) (!XMC_GPIO_GetInput(CAN_ID5_PORT, CAN_ID5_PIN) << 4);

	if ((board_id % 8 == 0 || board_id % 8 == 4) && XMC_GPIO_GetInput(CAN_ID6_PORT, CAN_ID6_PIN)) {
		chaser_start = 1;
	}
	else if (board_id % 8 == 1 || board_id % 8 == 5) {
		chaser_start = 9;
	}
	else if (board_id % 8 == 2 || board_id % 8 == 6) {
		chaser_start = 17;
	}

	CAN_Initialize();

	if (!XMC_GPIO_GetInput(CAN_ID6_PORT, CAN_ID6_PIN))		// Check Bit 6 of DIP Switch
		LED_Count = 23;		// CAN ID Position 6 ON ... 23 LEDs
	else if (XMC_GPIO_GetInput(CAN_ID6_PORT, CAN_ID6_PIN))
		LED_Count = 5;		// CAN ID Position 6 OFF ... 5 LEDs

	InitRGB(&strip, LED_RGBOUT_PORT, LED_RGBOUT_PIN, LED_Count);

	#if (DEBUG_MODE)
		/* Start the CCU4 timer */
		current_mode = SENSOR_LED_Effect_PulsingLight;
		XMC_CCU4_SLICE_StartTimer(TIMER_LED_HW);
	#endif

	while (1) {

    }
}
